<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Draggable Pin on Website Content</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* ----------------------------------------
       Section 2 Container (“Draggable Area”)
    ---------------------------------------- */
    #draggableContainer {
      position: relative;
      width: 90%;
      max-width: 800px;
      background-color: #0D0D0D;
      padding: 90px;
      box-sizing: border-box;
      min-height: 500px;
      z-index: 1;
    }

    /* ----------------------------------------
       Draggable Pin Wrapper
       - Using fixed positioning so it can move freely
    ---------------------------------------- */
 #draggablePinWrapper {
    position: absolute;
    cursor: grab;
    touch-action: none;
    transition: transform 0.3s ease-in-out;
    will-change: transform;
    z-index: 100;
 }
    #draggablePinWrapper.dragging {
    cursor: grabbing;
    transition: transform 0.06s ease-out; /* small but still animated */
    }
    /* ----------------------------------------
       Pin Image Drop Shadow
       - Respects pin’s transparent shape
    ---------------------------------------- */
    #draggablePinWrapper img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      pointer-events: none;
      filter: drop-shadow(0 0 10px rgba(0, 123, 255, 0.8));
    }
  </style>
</head>

<body class="bg-[#0D0D0D] text-white min-h-screen overflow-x-hidden font-sans antialiased">
  <!-- =================================
       SECTION 1 (Dummy content above)
       ================================= -->
  <section class="metabrain relative min-h-[1700px] overflow-hidden pt-32">
    <!-- SECTION 2: Draggable Container -->
    <div
      id="draggableContainer"
      class="relative md:absolute md:top-[1px] md:left-[360px] md:text-left text-80 text-center w-full md:w-auto overflow-visible pt-32 snap-target-row"
    >
      <h1
        class="text-4xl font-bold mb-4 text-transparent bg-clip-text bg-gradient-to-r from-yellow-500 via-red-500 to-pink-500"
      >
        Knowledge at
        <span
          class="text-transparent bg-clip-text bg-gradient-to-r from-yellow-500 via-red-500 to-pink-500"
          >Fingertips</span
        >
      </h1>
      <p class="max-w-xl mx-auto md:mx-0 mb-12" style="color: #A0A0A0;">
        Huly offers a wide range of features to create and manage your project
        documentation. Huly’s suite of collaborative editing tools boosts team
        efficiency.
      </p>
      <!-- (If you have more content for Section 2, add it here) -->
    </div>
  </section>

  <!-- =================================
       DRAGGABLE PIN (floats over entire screen)
       ================================= -->
  <div id="draggablePinWrapper" style="left: 100px; top: 100px;">
    <div class="relative w-[66px] h-[66px]">
      <img
        id="draggablebox"
        src="blue-pin.png"
        alt="pin"
        class="relative w-full h-full object-contain pointer-events-none"
      />
    </div>
  </div>

  <!-- =================================
       JAVASCRIPT: Horizontal Drag + Vertical Snap
       ================================= -->
  <script>
const draggableBox = document.getElementById('draggablePinWrapper');
const draggableContainer = document.getElementById('draggableContainer');
const snapTargetRow = document.querySelector('.snap-target-row');

let isDragging = false;
let offsetX, offsetY;
let lastX = 0, lastY = 0;
let velocityX = 0, velocityY = 0;
let animationFrame;

function getRect(element) {
    return element.getBoundingClientRect();
}

// Drag start (mouse + touch)
function startDrag(e) {
    isDragging = true;
    draggableBox.classList.add('dragging');

    const pointer = e.touches ? e.touches[0] : e;
    const boxRect = getRect(draggableBox);
    offsetX = pointer.clientX - boxRect.left;
    offsetY = pointer.clientY - boxRect.top;

    lastX = pointer.clientX;
    lastY = pointer.clientY;

    cancelAnimationFrame(animationFrame);
}

// Drag move (mouse + touch)
function duringDrag(e) {
    if (!isDragging) return;

    const pointer = e.touches ? e.touches[0] : e;
    const containerRect = getRect(draggableContainer);
    let newX = pointer.clientX - offsetX - containerRect.left;
    let newY = pointer.clientY - offsetY - containerRect.top;

    const boxRect = getRect(draggableBox);

    // Apply rubberband effect
    const bounce = 40;
    if (newX < 0) newX = -bounce + newX / 4;
    if (newX > containerRect.width - boxRect.width) newX = (containerRect.width - boxRect.width + bounce) - (containerRect.width - boxRect.width - newX) / 4;

    if (newY < 0) newY = -bounce + newY / 4;
    if (newY > containerRect.height - boxRect.height) newY = (containerRect.height - boxRect.height + bounce) - (containerRect.height - boxRect.height - newY) / 4;

    draggableBox.style.transform = `translate(${newX}px, ${newY}px)`;

    // Save velocity for momentum
    velocityX = pointer.clientX - lastX;
    velocityY = pointer.clientY - lastY;
    lastX = pointer.clientX;
    lastY = pointer.clientY;
}

// Drag end (mouse + touch)
function endDrag() {
    if (!isDragging) return;

    isDragging = false;
    draggableBox.classList.remove('dragging');

    // Momentum slide after release
    applyMomentum();

    // After momentum, snap smoothly
    setTimeout(() => {
        snapToTargetRowAndMaintainHorizontalPosition();
    }, 300); // Wait before snapping
}

// Apply momentum slide
function applyMomentum() {
    const containerRect = getRect(draggableContainer);
    const boxRect = getRect(draggableBox);
    const matrix = new WebKitCSSMatrix(window.getComputedStyle(draggableBox).transform);

    let currentX = matrix.m41;
    let currentY = matrix.m42;

    let step = 0;

    function animate() {
        velocityX *= 0.9;
        velocityY *= 0.9;
        currentX += velocityX;
        currentY += velocityY;

        // Clamp with bounce edges
        const maxX = containerRect.width - boxRect.width;
        const maxY = containerRect.height - boxRect.height;

        currentX = Math.max(-20, Math.min(currentX, maxX + 20));
        currentY = Math.max(-20, Math.min(currentY, maxY + 20));

        draggableBox.style.transform = `translate(${currentX}px, ${currentY}px)`;

        if (Math.abs(velocityX) > 0.5 || Math.abs(velocityY) > 0.5) {
            animationFrame = requestAnimationFrame(animate);
        }
    }

    animate();
}

// Snap logic (smooth)
function snapToTargetRowAndMaintainHorizontalPosition() {
    const containerRect = getRect(draggableContainer);
    const boxRect = getRect(draggableBox);
    const targetRowRect = getRect(snapTargetRow);

    const targetY = (targetRowRect.top + targetRowRect.height / 2) - containerRect.top - (boxRect.height / 2);

    const matrix = new WebKitCSSMatrix(window.getComputedStyle(draggableBox).transform);
    let targetX = matrix.m41;

    // Clamp to container
    targetX = Math.max(0, Math.min(targetX, containerRect.width - boxRect.width));

    draggableBox.style.transition = 'transform 0.6s ease-in-out';
    draggableBox.style.transform = `translate(${targetX}px, ${targetY}px)`;

    setTimeout(() => {
        draggableBox.style.transition = 'transform 0.06s linear'; // Restore for next drag
    }, 600);
}

// Mouse events
draggableBox.addEventListener('mousedown', startDrag);
document.addEventListener('mousemove', duringDrag);
document.addEventListener('mouseup', endDrag);

// Touch events
draggableBox.addEventListener('touchstart', startDrag);
document.addEventListener('touchmove', duringDrag, { passive: false });
document.addEventListener('touchend', endDrag);

// On load + resize
window.onload = snapToTargetRowAndMaintainHorizontalPosition;
window.addEventListener('resize', snapToTargetRowAndMaintainHorizontalPosition);
  </script>
</body>
</html>
